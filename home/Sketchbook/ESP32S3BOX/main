#include "driver/temp_sensor.h"  // Add this at the top with other includes

#include <ArduinoJson.h>
#include <Update.h>
#define BATTERY_ADC_PIN 10  // Replace with actual ADC pin
#define BATTERY_MIN_VOLTAGE 3.3  // Voltage at 0% (adjust to your battery)
#define BATTERY_MAX_VOLTAGE 4.2  // Voltage at 100%

float getBatteryVoltage() {
  int raw = analogRead(BATTERY_ADC_PIN);
  float voltage = (raw / 4095.0) * 3.3 * 2.0; // 12-bit ADC, 3.3V ref, 2:1 divider
  return voltage;
}


int getBatteryPercentage() {
  float voltage = getBatteryVoltage();
  int percentage = (voltage - BATTERY_MIN_VOLTAGE) / (BATTERY_MAX_VOLTAGE - BATTERY_MIN_VOLTAGE) * 100;
  percentage = constrain(percentage, 0, 100);
  return percentage;
}


#include <Wire.h>
#include <WiFi.h>
#include <HTTPClient.h>
#include <WebServer.h>
#include <driver/i2s.h>

// Pin Definitions from your header
#define I2C_SDA         8
#define I2C_SCL         18
#define TS_IRQ          3
#define TFT_BL          45
#define I2S_SDIN        16
#define I2S_LRCK        47
#define I2S_SCLK        17
#define I2S_MCLK        2
#define PA_PIN          46
#define MUTE_PIN        1
#define TFT_RST         48
// I2C Configuration
#define I2C_SDA 8
#define I2C_SCL 18
#define ES7210_ADDR 0x40

// I2S Configuration
#define I2S_MIC_SERIAL_CLOCK 17    // BCLK
#define I2S_MIC_LEFT_RIGHT_CLOCK 47 // LRC
#define I2S_MIC_SERIAL_DATA 16     // DIN
#define I2S_PORT I2S_NUM_0

// Audio Parameters
#define SAMPLE_RATE 16000
#define SAMPLE_BITS 16
#define BUFFER_SIZE 1024

// I2C Addresses
#define ES7210_ADDR     0x40  // MIC ADC
#define TT21100_ADDR    0x24  // Touch Panel

// Audio settings
#define SAMPLE_RATE     16000  // 16KHz
#define SAMPLE_BITS     16
#define BUFFER_SIZE     1024

// WiFi & API
const char* ssid = "pungkula2";
const char* password = "XX";
const char* apiEndpoint = "https://192.168.1.111:25451/audio_upload";

// Global variables
volatile bool touchDetected = false;
bool isRecording = false;
unsigned long lastTouchTime = 0;
String lastError = "None";
WiFiClient client;
HTTPClient http;
WebServer server(80);  // HTTP server on port 80
// Add with other global variables
//String zigbeeDevicesHTML = "";
//unsigned long lastZigbeeFetch = 0;
const unsigned long ZIGBEE_UPDATE_INTERVAL = 300000; // 5 minutes
const char* zigbeeEndpoint = "http://192.168.1.111:25451/zigbee_devices";
String zigbeeDevicesHTML = "";
unsigned long lastZigbeeFetch = 0;

void handleOTAUploadForm() {
  String html = "<html><body><h1>OTA Update</h1>"
                "<form method='POST' action='/ota' enctype='multipart/form-data'>"
                "<input type='file' name='firmware'>"
                "<input type='submit' value='Upload'></form></body></html>";
  server.send(200, "text/html", html);
}


void fetchZigbeeDevices() {
    HTTPClient http;
    http.begin(zigbeeEndpoint);
    int httpCode = http.GET();
    
    if (httpCode == HTTP_CODE_OK) {
        String payload = http.getString();
        DynamicJsonDocument doc(4096);
        deserializeJson(doc, payload);
        JsonObject devices = doc.as<JsonObject>();
        
        zigbeeDevicesHTML = "";
        for (JsonPair kv : devices) {
            const char* id = kv.key().c_str();
            JsonObject device = kv.value().as<JsonObject>();
            const char* type = device["type"];
            const char* name = device["friendly_name"];
            const char* room = device["room"];

            if (strcmp(type, "light") == 0) {
                zigbeeDevicesHTML += R"(
                <div class="switch-label">
                  <div class="control-label"><span>💡</span> )";
                zigbeeDevicesHTML += name;
                zigbeeDevicesHTML += " (";
                zigbeeDevicesHTML += room;
                zigbeeDevicesHTML += R"()</div>
                  <label class="toggle">
                    <input type="checkbox" onchange="toggleZigbee(')";
                zigbeeDevicesHTML += id;
                zigbeeDevicesHTML += R"(', this.checked)">
                    <span class="slider"></span>
                  </label>
                </div>)";
            }
        }
    } else {
        Serial.println("Failed to fetch Zigbee devices");
    }
    http.end();
}

// ES7210 Register Configuration
void es7210_init() {
  Wire.beginTransmission(ES7210_ADDR);
  Wire.write(0x00); Wire.write(0x41);  // Power up, MCLK=BCK
  Wire.write(0x01); Wire.write(0x22);  // OSR=64
  Wire.write(0x02); Wire.write(0x50);  // Clock divider
  Wire.write(0x07); Wire.write(0x01);  // Enable ONLY ADC1 (mono)
  Wire.write(0x08); Wire.write(0x00);  // Disable other ADCs
  Wire.write(0x20); Wire.write(0x0A);  // LRCK divider
  Wire.write(0x21); Wire.write(0x0A);  // MCLK divider
  Wire.endTransmission();
  delay(50);
}
void initI2S() {
  i2s_config_t i2s_config = {
    .mode = (i2s_mode_t)(I2S_MODE_MASTER | I2S_MODE_RX),
    .sample_rate = SAMPLE_RATE,
    .bits_per_sample = I2S_BITS_PER_SAMPLE_16BIT,
    .channel_format = I2S_CHANNEL_FMT_ONLY_LEFT,
    .communication_format = I2S_COMM_FORMAT_STAND_I2S,
    .intr_alloc_flags = ESP_INTR_FLAG_LEVEL1,
    .dma_buf_count = 4,
    .dma_buf_len = BUFFER_SIZE,
    .use_apll = false,
    .tx_desc_auto_clear = false,
    .fixed_mclk = 0
  };

  i2s_pin_config_t pin_config = {
    .mck_io_num = 2,        // MCLK
    .bck_io_num = I2S_MIC_SERIAL_CLOCK,
    .ws_io_num = I2S_MIC_LEFT_RIGHT_CLOCK,
    .data_out_num = I2S_PIN_NO_CHANGE,
    .data_in_num = I2S_MIC_SERIAL_DATA
  };

  i2s_driver_install(I2S_PORT, &i2s_config, 0, NULL);
  i2s_set_pin(I2S_PORT, &pin_config);
}


void recordAudio(uint8_t* buffer, size_t buffer_size) {
  size_t bytes_read = 0;
  
  while (bytes_read < buffer_size) {
    size_t read_bytes = 0;
    i2s_read(I2S_PORT, 
             buffer + bytes_read, 
             buffer_size - bytes_read,
             &read_bytes,
             portMAX_DELAY);
    bytes_read += read_bytes;
  }
}

void initES7210() {
  Wire.begin(I2C_SDA, I2C_SCL);
  
  // Reset ES7210
  Wire.beginTransmission(ES7210_ADDR);
  Wire.write(0x00); // Chip ID register
  Wire.write(0xFF); // Reset value
  Wire.endTransmission();
  delay(10);

  // Configure clock
  Wire.beginTransmission(ES7210_ADDR);
  Wire.write(0x01); // Master mode register
  Wire.write(0x30); // MCLK = 256*Fs
  Wire.endTransmission();

  // Enable all microphones
  Wire.beginTransmission(ES7210_ADDR);
  Wire.write(0x02); // ADC enable register
  Wire.write(0x0F); // Enable all 4 channels
  Wire.endTransmission();

  // Set sample rate
  Wire.beginTransmission(ES7210_ADDR);
  Wire.write(0x03); // Sample rate register
  Wire.write(0x20); // 16kHz sample rate
  Wire.endTransmission();
  
  // Additional configuration (gain, filters, etc.)
  // ... add more registers as needed
}

void handleOTAUpload() {
  HTTPUpload& upload = server.upload();

  if (upload.status == UPLOAD_FILE_START) {
    Serial.printf("OTA: Start updating %s\n", upload.filename.c_str());
    if (!Update.begin()) {
      Serial.println("OTA: Update.begin() failed");
    }
  } else if (upload.status == UPLOAD_FILE_WRITE) {
    if (Update.write(upload.buf, upload.currentSize) != upload.currentSize) {
      Serial.println("OTA: Write failed");
    }
  } else if (upload.status == UPLOAD_FILE_END) {
    if (Update.end(true)) {
      Serial.println("OTA: Update successful");
    } else {
      Serial.printf("OTA: Update failed. Error #: %d\n", Update.getError());
    }
  }
}


// TT21100 Touch Detection
bool checkTouch() {
  Wire.beginTransmission(TT21100_ADDR);
  Wire.write(0x00);  // Status register
  if (Wire.endTransmission(false) != 0) return false;
  
  uint8_t bytesReceived = Wire.requestFrom(TT21100_ADDR, 1);
  if (bytesReceived == 1) {
    return (Wire.read() & 0x80) != 0;  // Check touch status bit
  }
  return false;
}
void handleZigbeeControl() {
  String id = server.arg("id");
  String state = server.arg("state");
  
  // Add your Zigbee control logic here
  Serial.printf("Controlling device %s: %s\n", id.c_str(), state.c_str());
  
  server.send(200, "text/plain", "OK");
}
// Touch Interrupt Handler
void IRAM_ATTR handleTouch() {
  if ((millis() - lastTouchTime) > 500) {  // Debounce 500ms
    touchDetected = true;
    lastTouchTime = millis();
  }
}


// New: Fetch devices from server

// New: Handle device control commands
void handleDeviceControl() {
  String id = server.arg("id");
  String command = server.arg("cmd");
  
  // Here you would send the command to your Zigbee system
  Serial.printf("Controlling device %s: %s\n", id.c_str(), command.c_str());
  
  // Simulated response - in real implementation, this would communicate with Zigbee
  server.send(200, "text/plain", "OK");
}





void stopRecording() {
}

void startE() {
}
// HTTP Server Handlers
void handleRoot() {
  float batteryVoltage = getBatteryVoltage();  // Read battery voltage

  // Calculate battery percentage (4.4V = 100%, 1.2V = 0%)
  int batteryPercent = 0;
  if (batteryVoltage >= 4.4) {
    batteryPercent = 100;
  } else if (batteryVoltage > 1.2) {
    batteryPercent = static_cast<int>((batteryVoltage - 1.2) * (100.0 / 3.2));
  }

  String motionStatus = "No motion";
  String temperature = "23.5 °C";
  String rfCode = "None received";
  String audioStatus = "Streaming";
  String uptime = String(millis() / 1000) + " sec";

  // Build HTML content with real-time values
  String html = R"rawliteral(
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>🦆'Dash</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="https://qwackify.duckdns.org/duckdash.css">
  <script>
    function toggleZigbee(id, state) {
      const statusEl = document.getElementById(`zigbee-${id}-status`);
      statusEl.textContent = state ? "On" : "Off";
      fetch(`/zigbee/control?id=${id}&state=${state ? 'on' : 'off'}`)
        .then(res => {
          if (!res.ok) alert("Zigbee toggle failed");
        });
    }
    function toggleZigbee(id, checked) {
      document.getElementById("zigbee-" + id + "-status").textContent = checked ? "On" : "Off";
      fetch(`/zigbee/control?id=${id}&state=${checked ? 'on' : 'off'}`)
        .then(res => {
          if (!res.ok) alert("Zigbee toggle failed for " + id);
        });
    }
    function toggleZigbee(id, checked) {
        fetch(`/zigbee/control?id=${encodeURIComponent(id)}&state=${checked ? 'on' : 'off'}`)
            .then(res => {
                if (!res.ok) alert(`Toggle failed for ${id}`);
            });
    }
    function toggleZigbee(id, checked) {
      const el = document.getElementById(`zigbee-${id}-status`);
      el.textContent = checked ? "On" : "Off";
      fetch(`/zigbee/control?id=${encodeURIComponent(id)}&state=${checked ? 'on' : 'off'}`)
        .then(res => {
          if (!res.ok) alert(`Toggle ${id} failed`);
        });
    }
    function toggleZigbee(id, state) {
      const statusEl = document.getElementById(`zigbee-${id}-status`);
      statusEl.textContent = state ? "On" : "Off";
      fetch(`/zigbee/control?id=${id}&state=${state ? 'on' : 'off'}`)
        .then(res => {
          if (!res.ok) alert("Zigbee toggle failed");
        });
    }
    function toggleRecording(checkbox) {
      const state = checkbox.checked;
      document.getElementById("recording-status").textContent = state ? "Recording" : "Stopped";
      toggleFeature("record", state);
    }  
    function toggleFeature(feature, state) {
      fetch(`/${feature}?state=${state ? 'on' : 'off'}`)
        .then(res => {
          if (!res.ok) alert("Toggle failed");
        });
    }
  </script>

</head>
<body>
  <div class="container">
    <header>
      <h1>🦆Dash for device boxy</h1>
    </header>
    
    <div class="battery-section">
      <div class="status-icon">🔋</div>
      <div class="battery-percent">)rawliteral" + String(batteryPercent) + R"rawliteral(%</div>
      <div class="battery-bar">
        <div class="battery-fill )rawliteral" +
        (batteryPercent > 50 ? "battery-high" : batteryPercent > 20 ? "battery-medium" : "battery-low") +
        R"rawliteral(" style="width:)rawliteral" + String(batteryPercent) + R"rawliteral(%"></div>
      </div>
      <div class="voltage">Voltage: )rawliteral" + String(batteryVoltage, 2) + R"rawliteral(V</div>
    </div>
    
    <div class="status-grid">
      <div class="status-item">
        <div class="status-icon">🌐</div>
        <div class="status-content">
          <div class="status-label">WiFi Status</div>
          <div class="status-value">)rawliteral" + 
          (WiFi.status() == WL_CONNECTED ? WiFi.localIP().toString() : "Disconnected") +
          R"rawliteral(</div>
        </div>
      </div>
      
      <div class="status-item">
        <div class="status-icon">❗</div>
        <div class="status-content">
          <div class="status-label">System Error</div>
          <div class="status-value">)rawliteral" + lastError + R"rawliteral(</div>
        </div>
      </div>


      <div class="status-item">
        <div class="status-icon">🔋</div>
        <div class="status-content">
          <div class="status-label">Battery Percent</div>
          <div class="status-value">)rawliteral" + String(batteryVoltage, 2) + R"rawliteral(V</div>
        </div>
      </div>


      <div class="status-item">
        <div class="status-icon">⚡</div>
        <div class="status-content">
          <div class="status-label">Voltage</div>
          <div class="status-value">)rawliteral" + String(batteryVoltage, 2) + R"rawliteral(V</div>
        </div>
      </div>
      
   
      <div class="status-item">
        <div class="status-icon">🕵️</div>
        <div class="status-content">
          <div class="status-label">Motion Sensor</div>
          <div class="status-value">Detected</div>
        </div>
      </div>
      
      
      <div class="status-item">
        <div class="status-icon">🌡️</div>
        <div class="status-content">
          <div class="status-label">Temperature</div>
          <div class="status-value">)rawliteral" + temperature + R"rawliteral(</div>
        </div>
      </div>

     
      
      <div class="status-item">
        <div class="status-icon">🎙️</div>
        <div class="status-content">
          <div class="status-label">Recording</div>
          <div class="status-value" style="display: flex; justify-content: space-between; align-items: center;">
            <span id="recording-status">)rawliteral" + (isRecording ? "Recording" : "Stopped") + R"rawliteral(</span>
            <label class="toggle" style="margin: 0;">
              <input type="checkbox" id="record-toggle" onchange="toggleRecording(this)" )rawliteral" +
              (isRecording ? "checked" : "") + R"rawliteral(>
              <span class="slider"></span>
            </label>
          </div>
        </div>
      </div>
      
      
      <div class="status-item">
        <div class="status-icon">💡</div>
        <div class="status-content">
          <div class="status-label">Backlight</div>
          <div class="status-value" style="display: flex; justify-content: space-between; align-items: center;">
            <span id="backlight-status">)rawliteral" + (digitalRead(TFT_BL) == HIGH ? "On" : "Off") + R"rawliteral(</span>
            <label class="toggle" style="margin: 0;">
              <input type="checkbox" id="backlight-toggle" onchange="toggleBacklight(this)" )rawliteral" +
              (digitalRead(TFT_BL) == HIGH ? "checked" : "") + R"rawliteral(>
              <span class="slider"></span>
            </label>
          </div>
        </div>
      </div>
      
      
      
      
      
      <div class="status-item">
        <div class="status-icon">📢</div>
        <div class="status-content">
          <div class="status-label">Amplifier</div>
          <div class="status-value" style="display: flex; justify-content: space-between; align-items: center;">
            <span id="amplifier-status">)rawliteral" + (digitalRead(PA_PIN) == HIGH ? "On" : "Off") + R"rawliteral(</span>
            <label class="toggle" style="margin: 0;">
              <input type="checkbox" id="amplifier-toggle" onchange="toggleAmplifier(this)" )rawliteral" +
              (digitalRead(PA_PIN) == HIGH ? "checked" : "") + R"rawliteral(>
              <span class="slider"></span>
            </label>
          </div>
        </div>
      </div>
      
    
      <div class="status-item">
        <div class="status-icon">⏱️</div>
        <div class="status-content">
          <div class="status-label">Uptime</div>
          <div class="status-value">)rawliteral" + uptime + R"rawliteral(</div>
        </div>
      </div>
      
      <div class="status-item">
        <div class="status-icon">🔇</div>
        <div class="status-content">
          <div class="status-label">Button Mute</div>
          <div class="status-value">)rawliteral" + (digitalRead(MUTE_PIN) == LOW ? "PRESSED" : "RELEASED") + R"rawliteral(</div>
        </div>
      </div>

      <div class="status-item">
        <div class="status-icon">📡</div>
        <div class="status-content">
          <div class="status-label">RF Receiever</div>
          <div class="status-value">)rawliteral" + rfCode + R"rawliteral(</div>
        </div>
      </div>

      
      <div class="status-item">
        <div class="status-icon">📡</div>
        <div class="status-content">
          <div class="status-label">RF Transmitter</div>
          <div class="status-value">)rawliteral" + rfCode + R"rawliteral(</div>
        </div>
      </div>
    </div>
    
    <div class="controls">
      <h2 style="margin-bottom: 20px; text-align: center; color: #2b6cb0;">Device Controls</h2>
      
      <div class="switch-label">
        <div class="control-label"><span>💡</span> Backlight</div>
        <label class="toggle">
          <input type="checkbox" onchange="toggleFeature('backlight', this.checked)" )rawliteral" +
        (digitalRead(TFT_BL) == HIGH ? "checked" : "") + R"rawliteral(>
          <span class="slider"></span>
        </label>
      </div>
      
      <div class="switch-label">
        <div class="control-label"><span>🔊</span> Amplifier</div>
        <label class="toggle">
          <input type="checkbox" onchange="toggleFeature('amplifier', this.checked)" )rawliteral" +
        (digitalRead(PA_PIN) == HIGH ? "checked" : "") + R"rawliteral(>
          <span class="slider"></span>
        </label>
      </div>
      
      <div class="switch-label">
        <div class="control-label"><span>🎙️</span> Recording</div>
        <label class="toggle">
          <input type="checkbox" onchange="toggleFeature('record', this.checked)" )rawliteral" +
        (isRecording ? "checked" : "") + R"rawliteral(>
          <span class="slider"></span>
        </label>
      </div>
      

            <!-- ADD THIS SECTION FOR ZIGBEE DEVICES -->
            <h3 style="margin-top: 20px; text-align: center; color: #2b6cb0;">Zigbee Lights</h3>
            )rawliteral";
            
    // Insert Zigbee devices HTML here
    html += zigbeeDevicesHTML;
    
    // Continue with footer
    html += R"rawliteral(
        </div>
        <div class="footer">...</div>
    </body>
    </html>
    )rawliteral";
    
    server.send(200, "text/html", html);
      
    <div class="footer">
      <p>DuckBox 9000 | Firmware v1.2 | ESP32S3BOX</p>
    </div>
  </div>
</body>
</html>
)rawliteral";

  server.send(200, "text/html", html);
}
void handleBacklight() {
  if (server.arg("state") == "on") {
    digitalWrite(TFT_BL, HIGH);
  } else if (server.arg("state") == "off") {
    digitalWrite(TFT_BL, LOW);
  }
  server.sendHeader("Location", "/");
  server.send(302, "text/plain", "Redirecting...");
}

void handleAmplifier() {
  if (server.arg("state") == "on") {
    digitalWrite(PA_PIN, HIGH);
  } else if (server.arg("state") == "off") {
    digitalWrite(PA_PIN, LOW);
  }
  server.sendHeader("Location", "/");
  server.send(302, "text/plain", "Redirecting...");
}

//void handleRecord() {
//  if (server.arg("state") == "start") {
//    startRecording();
//  } else if (server.arg("state") == "stop") {
////
//  server.sendHeader("Location", "/");
//  server.send(302, "text/plain", "Redirecting...");
//}

void handleReset() {
  lastError = "None";
  server.sendHeader("Location", "/");
  server.send(302, "text/plain", "Redirecting...");
}

void setup() {
  Serial.begin(115200);
  delay(1000);  // Allow serial monitor to open
  server.on("/zigbee/control", handleZigbeeControl); 

  lastZigbeeFetch = 0;  // Force immediate fetch
  fetchZigbeeDevices(); // Initial fetch
  server.on("/device/control", handleDeviceControl);


  // Initialize pins
  pinMode(PA_PIN, OUTPUT);
  pinMode(MUTE_PIN, INPUT_PULLUP);
  pinMode(TFT_BL, OUTPUT);
  pinMode(TFT_RST, OUTPUT);
  
  // Reset and initialize display
  digitalWrite(TFT_RST, LOW);
  delay(100);
  digitalWrite(TFT_RST, HIGH);
  delay(100);
  digitalWrite(TFT_BL, LOW);  // Start with backlight off
  
  // Initialize I2C
  Wire.begin(I2C_SDA, I2C_SCL);
  
  // Configure touch interrupt
  pinMode(TS_IRQ, INPUT_PULLUP);
  attachInterrupt(digitalPinToInterrupt(TS_IRQ), handleTouch, FALLING);
  
  // Initialize ES7210 microphone
  es7210_init();
  
  // Fixed I2S configuration with proper settings
i2s_config_t i2s_config = {
    .mode = (i2s_mode_t)(I2S_MODE_MASTER | I2S_MODE_RX),
    .sample_rate = SAMPLE_RATE,
    .bits_per_sample = I2S_BITS_PER_SAMPLE_16BIT,
    .channel_format = I2S_CHANNEL_FMT_ONLY_LEFT, // MONO audio (1 channel)
    .communication_format = I2S_COMM_FORMAT_STAND_I2S,
    .intr_alloc_flags = ESP_INTR_FLAG_LEVEL1,
    .dma_buf_count = 8,
    .dma_buf_len = 1024,
    .use_apll = true
};
  
  i2s_pin_config_t pin_config = {
    .bck_io_num = I2S_SCLK,
    .ws_io_num = I2S_LRCK,
    .data_out_num = -1,
    .data_in_num = I2S_SDIN
  };
  
  i2s_driver_install(I2S_NUM_0, &i2s_config, 0, NULL);
  i2s_set_pin(I2S_NUM_0, &pin_config);
  i2s_zero_dma_buffer(I2S_NUM_0);
  i2s_stop(I2S_NUM_0);
  
  // Connect to WiFi
  WiFi.begin(ssid, password);
  Serial.print("Connecting to WiFi");
  while (WiFi.status() != WL_CONNECTED) {
    delay(500);
    Serial.print(".");
  }
  Serial.println("\nConnected! IP: " + WiFi.localIP().toString());
 
  server.on("/ota", HTTP_GET, handleOTAUploadForm);
  server.on("/ota", HTTP_POST, []() {
  server.send(200, "text/plain", (Update.hasError()) ? "OTA Update Failed" : "OTA Update Success. Rebooting...");
  delay(1000);
  ESP.restart();
}, handleOTAUpload);
  // Setup HTTP server
  server.on("/", handleRoot);
  server.on("/backlight", handleBacklight);
  server.on("/amplifier", handleAmplifier);
//  server.on("/record", handleRecord);
  server.on("/reset", handleReset);
  server.begin();
  Serial.println("HTTP server started");
  
  // Test audio capture
  Serial.println("Testing audio capture...");
  size_t bytesRead = 0;
  int16_t testBuffer[10];
  i2s_start(I2S_NUM_0);
  i2s_read(I2S_NUM_0, testBuffer, sizeof(testBuffer), &bytesRead, 100);
  i2s_stop(I2S_NUM_0);
  Serial.printf("I2S test read %d bytes\n", bytesRead);
  
  // Turn on amplifier by default
  digitalWrite(PA_PIN, HIGH);
}

void loop() {
    server.handleClient();
    
    // Update Zigbee devices every 5 minutes
    if (millis() - lastZigbeeFetch > ZIGBEE_UPDATE_INTERVAL) {
        fetchZigbeeDevices();
        lastZigbeeFetch = millis();
    }
    delay(10);
}

void startRecording() {
  Serial.println("Recording started");
  digitalWrite(TFT_BL, HIGH);  // Turn on screen
  isRecording = true;
  i2s_start(I2S_NUM_0);
 
 ##  Begin HTTP connection
  http.begin(client, apiEndpoint);
  http.addHeader("Content-Type", "application/octet-stream");
}

void stopRecording() {
//  Serial.println("Recording stopped");
  isRecording = false;
  i2s_stop(I2S_NUM_0);
  digitalWrite(TFT_BL, LOW);  // Turn off screen
  http.end();
}

void streamAudio() {
  static uint8_t audioBuffer[BUFFER_SIZE * 2]; // 16-bit mono = 2 bytes/sample
  size_t bytesRead = 0;
  
  // Read audio (non-blocking)
  i2s_read(I2S_NUM_0, audioBuffer, sizeof(audioBuffer), &bytesRead, 0);

  if (bytesRead > 0) {
    // Send chunk via HTTP
    int httpCode = http.POST(audioBuffer, bytesRead);
    
    if (httpCode != HTTP_CODE_OK) {
      lastError = "HTTP Error: " + String(httpCode);
      stopRecording();
    }
  }
//}

