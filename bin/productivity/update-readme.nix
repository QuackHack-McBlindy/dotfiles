# dotfiles/bin/productivity/update-readme.nix
{ # ü¶Ü says ‚Æû updates da docs! - using build-time generated data
  self,
  lib,
  config,
  pkgs,
  cmdHelpers,
  ...
} : with lib; let 

  cfg = config.yo;
  # ü¶Ü says ‚Æû generator
  readmeConfig = pkgs.writeText "readme-config.json" (builtins.toJSON {
    scriptCount = builtins.length (builtins.attrNames cfg.scripts);
    scripts = builtins.mapAttrs (name: script: {
      voiceReady = script.voiceReady or false;
      voice = script.voice or null;
    }) cfg.scripts;
    
    voiceStats = {
      generatedPatterns = cfg.generatedPatterns;
      understandsPhrases = cfg.understandsPhrases;
    };
    
    # ü¶Ü says ‚Æû smart home configuration
    smartHome = {
      devices = config.house.zigbee.devices;
      scenes = config.house.zigbee.scenes;
      tvs = config.house.tv;
    };
    
    # ü¶Ü says ‚Æû user and host configs
    userConfig = config.this.user.me;
    hostConfig = config.this.host;
    
    # ü¶Ü says ‚Æû flake information
    flakePath = "${config.this.user.me.dotfilesDir}/flake.nix";
  });

  # ü¶Ü duck say ‚Æû quacky hacky helper 2 escape md special charizardz yo
  escapeMD = str: let
    replacements = [
      [ "\\" "\\\\" ]
      [ "*" "\\*" ]
      [ "`" "\\`" ]
      [ "_" "\\_" ]
      [ "[" "\\[" ]
      [ "]" "\\]" ]
    ];
  in
    lib.foldl (acc: r: replaceStrings [ (builtins.elemAt r 0) ] [ (builtins.elemAt r 1) ] acc) str replacements;

  # ü¶Ü duck say ‚Æû we build da scripts again but diz time for the READNE and diz time script names > links 
  helpTextFile = pkgs.writeText "yo-helptext.md" helpText;
  # ü¶Ü duck say ‚Æû markdown help text
  helpText = let 
    # ü¶Ü duck say ‚Æû URL escape helper for GitHub links
    escapeURL = str: builtins.replaceStrings [" "] ["%20"] str;
  
    # ü¶Ü duck say ‚Æû categorize scripts
    visibleScripts = lib.filterAttrs (_: script: script.visibleInReadme) cfg.scripts;
    groupedScripts = lib.groupBy (script: script.category) (lib.attrValues visibleScripts);
    sortedCategories = lib.sort (a: b: 
      # ü¶Ü duck wants ‚Æû system management to be listed first yo
      if a == "üñ•Ô∏è System Management" then true
      else if b == "üñ•Ô∏è System Management" then false
      else a < b # ü¶Ü duck say ‚Æû after dat everything else quack quack
    ) (lib.attrNames groupedScripts);
  
    # ü¶Ü duck say ‚Æû create table rows with category separatorz 
    rows = lib.concatMap (category:
      let # ü¶Ü duck say ‚Æû sort from A to √ñ  
        scripts = lib.sort (a: b: a.name < b.name) groupedScripts.${category};
      in
        [ # ü¶Ü duck say ‚Æû add **BOLD** header table row for category
          "| **${escapeMD category}** | | | |"
        ] 
        # ü¶Ü duck say ‚Æû each yo script goes into a table row
        ++ (map (script:
          let  # ü¶Ü duck say ‚Æû format list of aliases
            aliasList = if script.aliases != [] then
              concatStringsSep ", " (map escapeMD script.aliases)
            else "";
            # ü¶Ü duck say ‚Æû generate CLI parameter hints, with [] for optional/defaulted
            paramHint = concatStringsSep " " (map (param:
              if param.optional || param.default != null
              then "[--${param.name}]"
              else "--${param.name}"
            ) script.parameters);
            # ü¶Ü duck say ‚Æû render yo script name as link + parameters as plain text
            syntax = 
              if githubBaseUrl != "" then
                "[yo ${escapeMD script.name}](${githubBaseUrl}/${escapeURL script.filePath}) ${paramHint}"
              else
                "yo ${escapeMD script.name} ${paramHint}";
              
            # ü¶Ü duck say ‚Æû add voice ready indicator
            voiceIndicator = if script.voiceReady then "‚úÖ" else "üìõ";
          in 
            # ü¶Ü duck say ‚Æû voice indicator to the row
            "| ${syntax} | ${aliasList} | ${escapeMD script.description} | ${voiceIndicator} |"
        ) scripts)
    ) sortedCategories;

  in concatStringsSep "\n" rows;

  # ü¶Ü duck say ‚Æû constructs GitHub "blob" URL based on `config.this.user.me.repo` 
  githubBaseUrl = let # ü¶Ü duck say ‚Æû pattern match to extract username and repo name
    matches = builtins.match ".*github.com[:/]([^/]+)/([^/\\.]+).*" config.this.user.me.repo;
  in if matches != null then # ü¶Ü duck say ‚Æû if match - construct
    "https://github.com/${builtins.elemAt matches 0}/${builtins.elemAt matches 1}/blob/main"
  else ""; # ü¶Ü duck say ‚Æû no match? empty string

  # ü¶Ü says ‚Æû Template function
  makeTemplate = config: pkgs.writeText "README-template.md" ''
    <!-- AUTO-GENERATED - DO NOT EDIT DIRECTLY -->
    <!-- This file is generated by yo update-readme -->
    
    # ${config.title}
    
    ${config.badges}
    
    ## üìä Stats
    <!-- SCRIPT_STATS_START -->
    <!-- SCRIPT_STATS_END -->

    ## ü¶Ü DUCK CHALLENGE
    <!-- DUCKS_START -->
    <!-- DUCKS_END -->

    
    ## üöÄ yo CLI Reference
    <!-- YO_DOCS_START -->
    <!-- YO_DOCS_END -->
    
    ## üè† Smart Home Configuration
    <!-- DEVICES_SCENES_START -->
    <!-- DEVICES_SCENES_END -->
    
    ## ‚öôÔ∏è User Configuration
    <!-- USER_START -->
    <!-- USER_END -->
    
    ## üñ•Ô∏è Host Configuration
    <!-- HOST_START -->
    <!-- HOST_END -->
    
    ## üé® Theme Configuration
    <!-- THEME_START -->
    <!-- THEME_END -->
    
    ## üì¶ Flake Structure
    <!-- FLAKE_START -->
    <!-- FLAKE_END -->
    
    ## üîå Flake.nix
    <!-- FLAKE_NIX_START -->
    <!-- FLAKE_NIX_END -->
    
    ## üìû Contact
    <!-- CONTACT_START -->
    <!-- CONTACT_END -->
  '';

in {

  yo.scripts.update-readme = {
    description = "Updates documentation in README.md with current system state (uses build-time config)";
    category = "‚ö° Productivity";
    logLevel = "INFO";
    parameters = [
      { name = "readmePath"; description = "Path to README.md file"; type = "path"; optional = false; default = config.this.user.me.dotfilesDir + "/README.md"; }
    ]; 
    code = ''
      ${cmdHelpers}
      
      dt_info "Starting README update..."
      
      README_PATH="$readmePath"
      dt_debug "README.md Path: $README_PATH"
      CONFIG_FILE="${readmeConfig}"
      dt_debug "CONFIG_FILE: $CONFIG_FILE"
      if [ ! -f "$README_PATH" ]; then
        dt_error "README file not found: $README_PATH"
        exit 1
      fi
      
      if [ ! -f "$CONFIG_FILE" ]; then
        dt_error "Config file not found: $CONFIG_FILE"
        exit 1
      fi
      
      # ü¶Ü says ‚Æû parse da build-time JSON config
      dt_debug "Loading build-time configuration..."
      CONFIG_DATA=$(cat "$CONFIG_FILE")
      
      get_config_value() {
        echo "$CONFIG_DATA" | ${pkgs.jq}/bin/jq -r "$1"
      }
      
      # ü¶Ü says ‚Æû create temp files
      TEMP_README=$(mktemp)
      trap 'rm -f "$TEMP_README"' EXIT
      
      # ü¶Ü says ‚Æû Get system versions safely
      get_version() {
        case "$1" in
          nixos)
            nixos-version 2>/dev/null | cut -d. -f1-2 || echo "unknown"
            ;;
          kernel)
            uname -r 2>/dev/null | cut -d'-' -f1 || echo "unknown"
            ;;
          nix)
            nix --version 2>/dev/null | awk '{print $3}' || echo "unknown"
            ;;
          bash)
            bash --version 2>/dev/null | head -n1 | awk '{print $4}' | cut -d'(' -f1 || echo "unknown"
            ;;
          gnome)
            gnome-shell --version 2>/dev/null | awk '{print $3}' || echo "unknown"
            ;;   
          python)
            python3 --version 2>/dev/null | awk '{print $2}' || echo "unknown"
            ;;
          rust)
            rustc --version 2>/dev/null | awk '{print $2}' || echo "unknown"
            ;;  
          mqtt)
            mosquitto -h 2>/dev/null | awk '/^mosquitto version/{print $3}' || echo "unknown"
            ;;
          z2m)
            zigbee2mqtt --help 2>&1 | grep -oE 'zigbee2mqtt-[0-9]+\.[0-9]+\.[0-9]+' | head -n1 | cut -d'-' -f2 || echo "unknown"
            ;;
          *)
            echo "unknown"
            ;;
        esac
      }
      
      update_badges() {
        local file="$1"
        dt_debug "File: $file"
        dt_debug "Permissions: $(ls -la "$file" 2>/dev/null || echo "File not found")"
        dt_debug "Current user: $(whoami)"
  
        local temp_file=$(mktemp)
        
        # ü¶Ü duck say ‚Æû extract versions
        nixos_version=$(nixos-version | cut -d. -f1-2)
        kernel_version=$(uname -r | cut -d'-' -f1)
        nix_version=$(nix --version | awk '{print $3}')
        bash_version=$(bash --version | head -n1 | awk '{print $4}' | cut -d'(' -f1)
        gnome_version=$(gnome-shell --version | awk '{print $3}')
        python_version=$(python3 --version 2>/dev/null | awk '{print $2}' || echo "unknown")
        rustc_version=$(rustc --version 2>/dev/null | awk '{print $2}' || echo "unknown")
        mosquitto_version=$(mosquitto -h 2>&1 | awk '/^mosquitto version/{print $3}' || echo "unknown")
  
        # ü¶Ü duck say ‚Æû construct badge URLs
        nixos_badge="https://img.shields.io/badge/NixOS-''${nixos_version}-blue?style=flat-square\\&logo=NixOS\\&logoColor=white"
        linux_badge="https://img.shields.io/badge/Linux-''${kernel_version}-red?style=flat-square\\&logo=linux\\&logoColor=white"
        nix_badge="https://img.shields.io/badge/Nix-''${nix_version}-blue?style=flat-square\\&logo=nixos\\&logoColor=white"
        bash_badge="https://img.shields.io/badge/bash-''${bash_version}-red?style=flat-square\\&logo=gnubash\\&logoColor=white"
        gnome_badge="https://img.shields.io/badge/GNOME-''${gnome_version}-purple?style=flat-square\\&logo=gnome\\&logoColor=white"
        python_badge="https://img.shields.io/badge/Python-''${python_version}-%23FFD43B?style=flat-square\\&logo=python\\&logoColor=white"
        rust_badge="https://img.shields.io/badge/Rust-''${rustc_version}-orange?style=flat-square\\&logo=rust\\&logoColor=white"
        mosquitto_badge="https://img.shields.io/badge/Mosquitto-''${mosquitto_version}-yellow?style=flat-square\\&logo=eclipsemosquitto\\&logoColor=white"
  
        # ü¶Ü duck say ‚Æû use sed yo
        ${pkgs.gnused}/bin/sed \
          -e "s|https://img.shields.io/badge/NixOS-[^)]*|$nixos_badge|g" \
          -e "s|https://img.shields.io/badge/Linux-[^)]*|$linux_badge|g" \
          -e "s|https://img.shields.io/badge/Nix-[^)]*|$nix_badge|g" \
          -e "s|https://img.shields.io/badge/bash-[^)]*|$bash_badge|g" \
          -e "s|https://img.shields.io/badge/GNOME-[^)]*|$gnome_badge|g" \
          -e "s|https://img.shields.io/badge/Python-[^)]*|$python_badge|g" \
          -e "s|https://img.shields.io/badge/Rust-[^)]*|$rust_badge|g" \
          -e "s|https://img.shields.io/badge/Mosquitto-[^)]*|$mosquitto_badge|g" \
          "$file" > "$temp_file" && mv "$temp_file" "$file"
      }

      # ü¶Üsay‚Æûreplaces <!-- sections -->
      replace_section() {
        local marker="$1"
        local content_file="$2"
        local target_file="$3"
        
        ${pkgs.gawk}/bin/awk -v marker="$marker" -v content_file="$content_file" '
          BEGIN {
            while ((getline line < content_file) > 0) {
              content = content line "\n"
            }
            close(content_file)
            in_section = 0
          }
          
          $0 ~ "<!-- " marker "_START -->" {
            in_section = 1
            print
            print content
            next
          }
          
          $0 ~ "<!-- " marker "_END -->" {
            in_section = 0
            print
            next
          }
          
          !in_section {
            print
          }
        ' "$target_file" > "$TEMP_README" && mv "$TEMP_README" "$target_file"
      }
      
      generate_section() {
        local section="$1"
        local temp_file=$(mktemp)
        
        case "$section" in
          YO_DOCS)
            # ü¶Ü duck say ‚Æû  get generated help text
            HELP_CONTENT=$(<${helpTextFile})
          
            cat << 'EOF' > "$temp_file"
## üöÄ **yo CLI ü¶Ü**
The \`yo\` CLI is a framework designed to execute scripts defined in the \`./bin\` directory.  
It provides a unified interface for script execution, centralizes all help commands, and automatically validates parametrs and updates the documentation.  

**Usage:** \`yo <command> [arguments]\`  

### **Usage Examples:**  
The yo CLI supports flexible parameter parsing through two primary mechanisms:  

```bash
# Named Parameters  
$ yo deploy --host laptop --flake /home/pungkula/dotfiles

# Positional Parameters
$ yo deploy laptop /home/pungkula/dotfiles

# Scripts can also be executed with natural language text by typing:
$ yo do "is laptop overheating"
# Natural language voice commands are also supported, say:
"yo bitch reboot the laptop"

# If the server is not running, it can be manually started with:
$ yo transcribe
$ yo wake
```

### ‚ú® Available Commands
Set default values for your parameters to have them marked [optional]  
Add \`?\` to any command to run it in DEBUG mode  
| Command Syntax               | Aliases    | Description | VoiceReady |
|------------------------------|------------|-------------|--|
${helpText}
### ‚ùì Detailed Help
For specific command help: 
\`yo <command> --help\`
\`yo <command> -h\`
EOF
            ;;
            
          SCRIPT_STATS)
              # ü¶Ü says ‚Æû extract stats from config
              local total_scripts=$(get_config_value '.scriptCount')
              local voice_scripts=$(get_config_value '[.scripts[] | select(.voiceReady == true)] | length')
              local total_patterns=$(get_config_value '.voiceStats.generatedPatterns')
              local total_phrases=$(get_config_value '.voiceStats.understandsPhrases')
              local total_devices=$(get_config_value '.smartHome.devices | length')
              local total_scenes=$(get_config_value '.smartHome.scenes | length')
              local total_tvs=$(get_config_value '.smartHome.tvs | length')
    
              cat << EOF > "$temp_file"
- __$total_scripts qwacktastic scripts in /bin - $voice_scripts scripts have voice commands.__ <br>
- __$total_patterns dynamically generated regex patterns - makes $total_phrases phrases available as commands.__ <br>
- __Smart Home Nix Fu - Managing $total_tvs TV's, $total_devices devices & $total_scenes scenes.__ <br>
- __Natural Language DevOps support with complete voice pipeline__ <br>
- __Mobile Frontend with Chatbot (no LLM) - Less thinking, more doing!__ <br>
- __Infra as everyday accessibility__ <br>
- __Yubikey encrypted deployment system__ <br>
- __Version controlled ESP32 firmware management__ <br>      
- __Self Documenting__ <br>
EOF
              ;;
           DUCKS)
            # ü¶Ü says ‚Æû count dem ducks
            local total_ducks=0
            if [ -d "${config.this.user.me.dotfilesDir}" ]; then
              total_ducks=$(grep -ro 'ü¶Ü' --include='*.nix' --include='*.sh' --include='*.html' "${config.this.user.me.dotfilesDir}" 2>/dev/null | wc -l || echo 0)
            fi
            dt_info "Counting number of ü¶Ü...."
            dt_info "$total_ducks ü¶Ü's !!" 
      
            cat << EOF > "$temp_file"
I have hidden some ducks in the .nix files in this repository. <br>
Let's see if you can find all $total_ducks ducks? <br>
EOF
            ;;
                      
          USER)
            get_config_value '.userConfig' | ${pkgs.jq}/bin/jq -r '
              def to_nix($indent):
                def ind: ("  " * $indent);
                if type == "object" then
                  "\(ind){\n" + (
                    to_entries | map(
                      "\(ind)  \(.key) = \(.value | to_nix($indent + 1))"
                    ) | join(";\n")
                  ) + "\n\(ind)}"
                elif type == "array" then
                  if map(type == "string") | all then
                    "[ " + (map("\"\(.)\"") | join(" ")) + " ]"
                  else
                    "[\n" + (
                      map(to_nix($indent + 1)) | join("\n")
                    ) + "\n\(ind)]"
                  end
                elif type == "string" then
                  "\"\(.)\""
                else
                  tostring
                end;
              "```nix\n" + to_nix(0) + "\n```"
            ' > "$temp_file" 2>/dev/null || echo "```nix\n/* Error loading user config */\n```" > "$temp_file"
            ;;
            
          HOST)
            get_config_value '.hostConfig' | ${pkgs.jq}/bin/jq -r '
              def to_nix($indent):
                def ind: ("  " * $indent);
                if type == "object" then
                  "\(ind){\n" + (
                    to_entries | map(
                      "\(ind)  \(.key) = \(.value | to_nix($indent + 1))"
                    ) | join(";\n")
                  ) + "\n\(ind)}"
                elif type == "array" then
                  if map(type == "string") | all then
                    "[ " + (map("\"\(.)\"") | join(" ")) + " ]"
                  else
                    "[\n" + (
                      map(to_nix($indent + 1)) | join("\n")
                    ) + "\n\(ind)]"
                  end
                elif type == "string" then
                  "\"\(.)\""
                else
                  tostring
                end;
              "```nix\n" + to_nix(0) + "\n```"
            ' > "$temp_file" 2>/dev/null || echo "```nix\n/* Error loading host config */\n```" > "$temp_file"
            ;;
            
          FLAKE_NIX)
            local flake_path=$(get_config_value '.flakePath')
            if [ -f "$flake_path" ]; then
              echo '```nix' > "$temp_file"
              head -100 "$flake_path" >> "$temp_file"
              echo '```' >> "$temp_file"
            else
              echo "```nix\n/* flake.nix not found */\n```" > "$temp_file"
            fi
            ;;
            
          DEVICES_SCENES)
            cat << 'EOF' > "$temp_file"
### üì° Zigbee Devices
EOF
            
            get_config_value '.smartHome.devices[] | "  - \(.name) (\(.type))"' 2>/dev/null | while read -r device; do
              echo "$device" >> "$temp_file"
            done || true
            
            cat << 'EOF' >> "$temp_file"

### üé≠ Scenes
EOF
            
            get_config_value '.smartHome.scenes[] | "  - \(.name)"' 2>/dev/null | while read -r scene; do
              echo "$scene" >> "$temp_file"
            done || true
            
            cat << 'EOF' >> "$temp_file"

### üì∫ TV Configuration
EOF
            
            get_config_value '.smartHome.tvs[] | "  - \(.name) (\(.type)) - IP: \(.ip)"' 2>/dev/null | while read -r tv; do
              echo "$tv" >> "$temp_file"
            done || true
            ;;
            
          CONTACT)
            cat << EOF > "$temp_file"
$(
local matrix=$(get_config_value '.userConfig.matrix // ""')
local discord=$(get_config_value '.userConfig.discord // ""')
local email=$(get_config_value '.userConfig.email // ""')

[ -n "$matrix" ] && echo "[![Matrix](https://img.shields.io/badge/Matrix-Chat-000000?style=flat-square&logo=matrix&logoColor=white)]($matrix)"
[ -n "$discord" ] && echo "[![Discord](https://img.shields.io/badge/Discord-Chat-5865F2?style=flat-square&logo=discord&logoColor=white)]($discord)"
[ -n "$email" ] && echo "[![Email](https://img.shields.io/badge/Email-Contact-6D4AFF?style=flat-square&logo=protonmail&logoColor=white)](mailto:$email)"
)
EOF
            ;;           
          *)
            echo "<!-- No content for section: $section -->" > "$temp_file"
            ;;
        esac
        
        echo "$temp_file"
      }
      
      dt_info "Updating badges..."
      update_badges "$README_PATH"
      
      dt_info "Updating sections..."
      
      for section in YO_DOCS SCRIPT_STATS DUCKS DEVICES_SCENES USER HOST FLAKE_NIX CONTACT; do
        dt_debug "Updating section: $section..."
        content_file=$(generate_section "$section")
        if [ -f "$content_file" ]; then
          replace_section "$section" "$content_file" "$README_PATH"
          rm "$content_file"
        fi
      done
      
      size=$(wc -c < "$README_PATH")

      if (( size > 20 * 1024 )); then
        say_duck "üéâ‚ú® README UPDATED!"
      elif (( size == 0 )); then
        dt_error   "‚ö†Ô∏èüö´ README UPDATE FAILED! ‚ö†Ô∏èüö´"
        dt_warning "‚ö†Ô∏è README.md EXPECTEED BROKEN! Verify file content!"
      fi
      
      # ü¶Ü says ‚Æû show diff
      if git diff --quiet "$README_PATH" 2>/dev/null; then
        dt_debug "No changes to commit"
      else
        dt_debug "Changes detected:"
        git diff --stat "$README_PATH" 2>/dev/null || true
      fi
    '';

  };}
